/// BERK Ownership & Borrow Checker - Memory Safety Showcase
///
/// Bu demo BERK'in Rust seviyesinde bellek gÃ¼venliÄŸini gÃ¶sterir:
/// - Use-after-free Ã¶nleme (compile-time)
/// - Double-free Ã¶nleme (compile-time)
/// - Data race Ã¶nleme (compile-time)
/// - Null pointer eriÅŸimi Ã¶nleme

kullan std::thread
kullan std::sync

/// âŒ HATA: Use-after-free (Compile-time yakalanÄ±r!)
/*
fonksiyon use_after_free_example()
yap
    deÄŸiÅŸken data = yeni Vec<tamsayÄ±>
    data.push(42)
    
    deÄŸiÅŸken moved_data = taÅŸÄ±(data)  // Ownership moved
    
    // âŒ DERLEME HATASI: 'data' artÄ±k kullanÄ±lamaz!
    // yaz(data.len())  // Error: use of moved value
son
*/

/// âœ… DOÄRU: Ownership kurallarÄ±na uygun
fonksiyon ownership_correct_example()
yap
    deÄŸiÅŸken data = yeni Vec<tamsayÄ±>
    data.push(42)
    data.push(100)
    
    // Immutable borrow - âœ… OK
    deÄŸiÅŸken borrowed = &data
    yaz("Data length: ", borrowed.len())
    
    // Mutable borrow - âœ… OK (immutable borrow bittikten sonra)
    deÄŸiÅŸken borrowed_mut = &deÄŸiÅŸtir data
    borrowed_mut.push(200)
    
    yaz("Updated data: ", data)
son

/// âŒ HATA: AynÄ± anda immutable ve mutable borrow (Compile-time)
/*
fonksiyon borrow_conflict_example()
yap
    deÄŸiÅŸken data = yeni Vec<tamsayÄ±>
    
    deÄŸiÅŸken reader = &data           // Immutable borrow
    deÄŸiÅŸken writer = &deÄŸiÅŸtir data  // âŒ HATA: Already borrowed as immutable!
    
    writer.push(42)
    yaz(reader.len())
son
*/

/// âœ… DOÄRU: Borrow kurallarÄ±na uygun
fonksiyon borrow_correct_example()
yap
    deÄŸiÅŸken data = yeni Vec<tamsayÄ±>
    
    // Scope ile borrow lifetime yÃ¶netimi
    {
        deÄŸiÅŸken reader = &data
        yaz("Reading: ", reader.len())
    }  // reader scope sonu - borrow serbest!
    
    // Åimdi mutable borrow alÄ±nabilir
    {
        deÄŸiÅŸken writer = &deÄŸiÅŸtir data
        writer.push(42)
    }
    
    yaz("Final data: ", data)
son

/// Thread Safety - Data Race Prevention
fonksiyon thread_safety_example()
yap
    yaz("\n=== Thread Safety Demo ===\n")
    
    // Shared counter - Arc (Atomic Reference Counted)
    deÄŸiÅŸken counter = sync::Arc::new(sync::Mutex::new(0))
    
    deÄŸiÅŸken handles = yeni Vec<thread::JoinHandle<()>>
    
    // 10 thread oluÅŸtur
    iÃ§in i iÃ§inde 0..10
        deÄŸiÅŸken counter_clone = counter.clone()
        
        deÄŸiÅŸken handle = thread::spawn(taÅŸÄ± || {
            iÃ§in _ iÃ§inde 0..1000
                // Mutex lock ile thread-safe eriÅŸim
                deÄŸiÅŸken guard = counter_clone.lock().unwrap()
                *guard += 1
                // guard drop olunca otomatik unlock
            son
        })
        
        handles.push(handle)
    son
    
    // TÃ¼m thread'leri bekle
    iÃ§in handle iÃ§inde handles
        handle.join().unwrap()
    son
    
    deÄŸiÅŸken final_count = *counter.lock().unwrap()
    yaz("Final counter (thread-safe): ", final_count)
    yaz("Beklenen: 10,000")
    yaz("SonuÃ§: ", eÄŸer final_count == 10000 "âœ… BAÅARILI!" deÄŸilse "âŒ Data race var!")
son

/// âŒ C++ Style Data Race (BERK buna izin vermez!)
/*
// C++ kod Ã¶rneÄŸi (yorum olarak):
// int counter = 0;  // Shared
// 
// void thread_func() {
//     for (int i = 0; i < 1000; i++)
//         counter++;  // âŒ DATA RACE!
// }
//
// BERK'te bu kod DERLENMEYECEKTÄ°R!
// Ã‡Ã¼nkÃ¼ 'counter' paylaÅŸÄ±mlÄ± mutable eriÅŸime izin vermez.
*/

/// Non-Lexical Lifetimes (NLL) Demo
fonksiyon nll_example()
yap
    yaz("\n=== Non-Lexical Lifetimes ===\n")
    
    deÄŸiÅŸken data = yeni Vec<tamsayÄ±>
    data.push(1)
    data.push(2)
    data.push(3)
    
    deÄŸiÅŸken first = &data[0]
    yaz("First element: ", first)
    // 'first' burada son kez kullanÄ±lÄ±yor - borrow burada bitiyor!
    
    // Åimdi mutable borrow alÄ±nabilir (NLL sayesinde)
    data.push(4)  // âœ… OK - 'first' artÄ±k kullanÄ±lmÄ±yor
    
    yaz("Data after push: ", data)
son

/// Smart Pointers - Box, Rc, Arc
fonksiyon smart_pointer_example()
yap
    yaz("\n=== Smart Pointers ===\n")
    
    // Box - Heap allocation with ownership
    deÄŸiÅŸken boxed = Box::new(42)
    yaz("Boxed value: ", *boxed)
    
    // Rc - Reference Counted (single-threaded)
    deÄŸiÅŸken rc1 = sync::Rc::new(100)
    deÄŸiÅŸken rc2 = rc1.clone()
    yaz("RC count: ", sync::Rc::strong_count(&rc1))  // 2
    
    // Arc - Atomic Reference Counted (thread-safe)
    deÄŸiÅŸken arc1 = sync::Arc::new(200)
    deÄŸiÅŸken arc2 = arc1.clone()
    yaz("ARC count: ", sync::Arc::strong_count(&arc1))  // 2
son

/// Lifetime Annotations - Explicit lifetimes
fonksiyon longest<'a>(x: &'a metin, y: &'a metin) -> &'a metin
yap
    eÄŸer x.len() > y.len()
        dÃ¶n x
    deÄŸilse
        dÃ¶n y
    son
son

fonksiyon lifetime_example()
yap
    yaz("\n=== Lifetimes ===\n")
    
    deÄŸiÅŸken str1 = "hello"
    deÄŸiÅŸken str2 = "world!"
    
    deÄŸiÅŸken result = longest(str1, str2)
    yaz("Longest string: ", result)
son

/// Memory leak prevention
fonksiyon no_memory_leak_example()
yap
    yaz("\n=== Memory Leak Prevention ===\n")
    
    // BERK'te memory leak OLMAZ Ã§Ã¼nkÃ¼:
    // 1. Ownership sistemi otomatik cleanup yapar
    // 2. Drop trait otomatik Ã§aÄŸrÄ±lÄ±r
    // 3. Reference counting (Rc/Arc) cycle detection
    
    deÄŸiÅŸken items = yeni Vec<Box<tamsayÄ±>>
    
    iÃ§in i iÃ§inde 0..1000
        items.push(Box::new(i))
    son
    
    // Function sonunda 'items' drop edilir
    // Bu otomatik olarak tÃ¼m Box'larÄ± serbest bÄ±rakÄ±r
    // MANUEL FREE GEREKLÄ° DEÄÄ°L!
    
    yaz("1000 allocation yapÄ±ldÄ± - hepsi otomatik temizlenecek")
son

/// Ana fonksiyon
fonksiyon ana() -> tamsayÄ±
yap
    yaz("â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—")
    yaz("â•‘  BERK Ownership & Memory Safety Showcase         â•‘")
    yaz("â•‘  Rust-Level Safety Without Runtime Overhead      â•‘")
    yaz("â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n")
    
    yaz("ğŸ”’ Compile-Time Safety Guarantees:")
    yaz("   âœ… No use-after-free")
    yaz("   âœ… No double-free")
    yaz("   âœ… No data races")
    yaz("   âœ… No null pointer dereference")
    yaz("   âœ… No memory leaks\n")
    
    // Demo'larÄ± Ã§alÄ±ÅŸtÄ±r
    ownership_correct_example()
    borrow_correct_example()
    thread_safety_example()
    nll_example()
    smart_pointer_example()
    lifetime_example()
    no_memory_leak_example()
    
    yaz("\nâ•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—")
    yaz("â•‘                   KARÅILAÅTIRMA                   â•‘")
    yaz("â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£")
    yaz("â•‘  C/C++:    Runtime crashes, undefined behavior    â•‘")
    yaz("â•‘  Python:   Garbage collector overhead             â•‘")
    yaz("â•‘  Go:       GC pauses, limited control             â•‘")
    yaz("â•‘  Rust:     âœ… Compile-time safety (baseline)      â•‘")
    yaz("â•‘  BERK:     âœ… Rust safety + 263x region memory!   â•‘")
    yaz("â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n")
    
    yaz("ğŸ’¡ BERK AvantajlarÄ±:")
    yaz("   â€¢ Zero-cost abstractions (no runtime overhead)")
    yaz("   â€¢ Compile-time guarantees (no runtime checks)")
    yaz("   â€¢ Thread safety without GC")
    yaz("   â€¢ Memory safety without GC")
    yaz("   â€¢ Performance + Safety birlikte!")
    
    dÃ¶n 0
son
